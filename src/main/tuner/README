This directory contains programs that implement the automatic
performance tuner.

-------------------------------------------------------------

There are four major parts that constitute the automatic performance
tuner.

1. The performance tuner's main class.
   Class: PerfTuner
   File: tuner.py

   This serves as the main entry of the automatic performance tuning
   process.

2. The code generator used to produce the performance-testing code.
   Class: PerfTestCodeGen 
   File: ptest_codegen.py

   This code generator produces code used to measure the performance
   of the transformed code. The transformed code fragment is the main
   input argument. Other than that, it also takes the input parameters
   (i.e. input arrays and their dimension sizes) to generate array
   declarations and array initializations.

   The CODE_TEMPLATE is the code skeleton. It has five different tags
   (i.e. incls, macros, decls, inits, code), each starts with '/*@'
   and ends with '@*/'. These tags are used to mark the locations of
   where we should put the array/dimension declarations, array
   initializations, the transformed code, etc.

   This performance-testing code generation is still very basic and
   needs to be improved to handle more general cases.

3. The driver that initiates the compilation and execution of the
   generated performance-testing code.
   Class: PerfTestDriver class 
   File: ptest_driver.py

   The main function of this driver to take the performance-testing
   code as input, and then to write the code into a file, to compile
   and to execute it, and to obtain the execution time.

   Other than the performance-testing code, this driver takes as input
   the compiler command and the compiler options for compiling the
   testing code. Users can specify this information in the tuning
   specification file as seen in the following.

   def compilers  
   { 
     arg command = 'icc';
     arg options = '-O3 -lm'; 
   } 
 
   def performance_counter  
   { 
     arg method = 'total time'; 
     arg repetitions = 10; 
   } 

   The 'performance_counter' definition is used to denote the
   performance-counting technique. From the above example, the
   performance counting is repeated ten times. This is done by
   providing -DREPS=10 compiler option.

4. The search engine used for the exploration of the search space.
   Class: Search 
   File: search/search.py
     
   The search engine has various search algorithms implemented to
   explore the search space. The most basic algorithm is the
   exhaustive search. Each search module is implemented as a class
   defined in a subdirectory under the search/ directory. The search
   algorithm is loaded dynamically, based on the search name specified
   by the user.

   User specifies the search strategy to be used, along with its
   search arguments. The search specifications are written in the
   tuning specification file. Below is one example that defines a
   simplex search method.

   def search 
   { 
     arg algorithm = 'Simplex';   
     arg time_limit = 10; 
 
     # below are search-specific arguments
     arg simplex_local_distance = 1;  
     arg simplex_reflection_coef = 1.0; 
     arg simplex_expansion_coef = [1.5, 2.0]; 
     arg simplex_contraction_coef = [0.5, 0.75]; 
     arg simplex_shrinkage_coef = 0.7; 
   } 



