-------------------------------
 Generalized Register Tiling
-------------------------------

This directory contains code that implements register tiling, which is equivalent to loop tiling
for register-level memory hierarchy. This optimization is also known as loop unrolling and jamming.
Our register tiling approach is so generalized that it can handle non-rectangular iteration spaces, 
where loop bounds of the inner loops may contain some iteration variables of the outer loops. 
The loop bounds may be either affine or non-affine functions.

Next, we explain our register tiling approach through a simple example.

-------------------------------------------------------

Suppose we have the following 2-D imperfectly nested loops:

for i=lbi, ubi, sti
  S1(i)
  for j=lbj(i), ubj(i), stj
    S2(i,j)
  S3(i)
  for k=lbk, ubk, stk
    S4(i,k)

which have the corresponding unrolled-and-jammed loop nest (with unroll factors of TixTjxTk) 
as follows:

for it=lbi, ubi-Ti+sti, Ti
  S1_unroll_jam(it) with Ti
  new_lbj = -inf
  new_ubj = +inf
  for i=it, it+Ti-sti, sti
    new_lbj = max(new_lbj, lbj(i))
    new_ubj = min(new_ubj, ubj(i))
  for i=it, it+Ti-sti, sti
    for j=lbj(i), new_lbj-stj, stj
      S2(i,j)
  for jt=new_lbj, new_ubj-Tj+stj, Tj
    S2_unroll_jam(it,jt) with TixTj
  for j=jt, new_ubj, stj
    S2_unroll_jam(it,j) with Tix1
  for i=it, it+Ti-sti, sti
    for j=new_ubj+stj, ubj(i), stj
      S2(i,j)
  S3_unroll_jam(it) with Ti
  for kt=lbk, ubk-Tk+stk, Tk
    S4_unroll_jam(it,kt) with TixTk
  for k=kt, ubk, stk
    S4_unroll_jam(it,k) with Tix1

new_lbj = -inf
new_ubj = +inf
for i=it, ubi, sti
  new_lbj = max(new_lbj, lbj(i))
  new_ubj = min(new_ubj, ubj(i))
for i=it, ubi, sti
  S1(i)
  for j=lbj(i), new_lbj-stj, stj
    S2(i,j)
  for jt=new_lbj, new_ubj-Tj+stj, Tj
    S2_unroll_jam(i,jt) with 1xTj
  for j=jt, new_ubj, stj
    S2(i,j)
  for j=new_ubj+stj, ubj(i), stj
    S2(i,j)
  S3(i)
  for kt=lbk, ubk-Tk+stk, Tk
    S4_unroll_jam(i,kt) with 1xTk
  for k=kt, ubk, stk
    S4(i,k)

The example above shows how to unroll and jam a 2-D loop nest for both non-rectangular and 
rectangular cases, shown by the inner loops j and k, respectively.

-------------------------------------------------------

Now, let us see how to perform register tiling with unroll factor of 1 (i.e. no unrolling).

*** Ti=1 and Tk=1

for i=lbi, ubi, sti
  for k=lbk, ubk, stk
    S(i,k)

*** Ti!=1 and Tk=1

for it=lbi, ubi-Ti+sti, Ti
  for k=lbk, ubk, stk
    S_unroll_jam(it,k) with Tix1
for i=it, ubi, sti
  for k=lbk, ubk, stk
    S(i,k)

*** Ti=1 and Tk!=1

for i=lbi, ubi, sti
  for kt=lbk, ubk-Tk+stk, Tk
    S_unroll_jam(i,kt) with 1xTk
  for k=kt, ubk, stk
    S(i,k)

*** Ti!=1 and Tk!=1

for it=lbi, ubi-Ti+sti, Ti
  for kt=lbk, ubk-Tk+stk, Tk
    S_unroll_jam(it,kt) with TixTk
  for k=kt, ubk, stk
    S_unroll_jam(it,k) with Tix1
for i=it, ubi, sti
  for kt=lbk, ubk-Tk+stk, Tk
    S_unroll_jam(i,kt) with 1xTk
  for k=kt, ubk, stk
    S(i,k)

-------------------------------------------------------

*** Ti=1 and Tj=1

for i=lbi, ubi, sti
  for j=lbj(i), ubj(i), stj
    S(i,j)

*** Ti!=1 and Tj=1

for it=lbi, ubi-Ti+sti, Ti
  for i=it, it+Ti-sti, sti
    for j=lbj(i), ubj(i), stj
      S(i,j)
for i=it, ubi, sti
  for j=lbj(i), ubj(i), stj
    S(i,j)

*** Ti=1 and Tj!=1

new_lbj = -inf
new_ubj = +inf
for i=lbi, ubi, sti
  new_lbj = max(new_lbj, lbj(i))
  new_ubj = min(new_ubj, ubj(i))
for i=lbi, ubi, sti
  for j=lbj(i), new_lbj-stj, stj
    S(i,j)
  for jt=new_lbj, new_ubj-Tj+stj, Tj
    S_unroll_jam(i,jt) with 1xTj
  for j=jt, new_ubj, stj
    S(i,j)
  for j=new_ubj+stj, ubj(i), stj
    S(i,j)

*** Ti!=1 and Tj!=1

for it=lbi, ubi-Ti+sti, Ti
  new_lbj = -inf
  new_ubj = +inf
  for i=it, it+Ti-sti, sti
    new_lbj = max(new_lbj, lbj(i))
    new_ubj = min(new_ubj, ubj(i))
  for i=it, it+Ti-sti, sti
    for j=lbj(i), new_lbj-stj, stj
      S(i,j)
  for jt=new_lbj, new_ubj-Tj+stj, Tj
    S_unroll_jam(it,jt) with TixTj
  for j=jt, new_ubj, stj
    S_unroll_jam(it,j) with Tix1
  for i=it, it+Ti-sti, sti
    for j=new_ubj+stj, ubj(i), stj
      S(i,j)
new_lbj = -inf
new_ubj = +inf
for i=it, ubi, sti
  new_lbj = max(new_lbj, lbj(i))
  new_ubj = min(new_ubj, ubj(i))
for i=it, ubi, sti
  for j=lbj(i), new_lbj-stj, stj
    S(i,j)
  for jt=new_lbj, new_ubj-Tj+stj, Tj
    S_unroll_jam(i,jt) with 1xTj
  for j=jt, new_ubj, stj
    S(i,j)
  for j=new_ubj+stj, ubj(i), stj
    S(i,j)

-------------------------------------------------------

Now, how do we handle a 3-D (or more) loop nest?

*** Ti=1 and Tj=1 and Tk=1



*** Ti=1 and Tj=1 and Tk!=1

*** Ti=1 and Tj!=1 and Tk=1

*** Ti=1 and Tj!=1 and Tk!=1

*** Ti!=1 and Tj=1 and Tk=1

*** Ti!=1 and Tj=1 and Tk!=1

*** Ti!=1 and Tj!=1 and Tk=1

*** Ti!=1 and Tj!=1 and Tk!=1

-------------------------------------------------------

Generalized code generation for register tiling?



